/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package eu.visualize.ini.convnet;

import java.awt.Color;
import java.awt.Point;
import java.beans.PropertyChangeEvent;
import java.util.Arrays;

import javax.swing.SwingUtilities;

import com.jogamp.opengl.GL2;
import com.jogamp.opengl.GLAutoDrawable;

import ch.unizh.ini.jaer.projects.util.ColorHelper;
import com.jogamp.opengl.GL;
import com.jogamp.opengl.GLException;
import net.sf.jaer.Description;
import net.sf.jaer.DevelopmentStatus;
import net.sf.jaer.chip.AEChip;
import net.sf.jaer.event.BasicEvent;
import net.sf.jaer.event.EventPacket;
import net.sf.jaer.event.PolarityEvent;
import net.sf.jaer.eventprocessing.FilterChain;
import net.sf.jaer.graphics.AEFrameChipRenderer;
import net.sf.jaer.graphics.MultilineAnnotationTextRenderer;

/**
 * Runs CNN on patches generated by accumulated DVS subframes generated by
 * DvsDataDrivenROIGenerator to dynamically update a heat map in a data-driven
 * way.
 *
 * @author Tobi Delbruck
 *
 */
@Description("using data-driven ROIs from DVS events to update heat map by running CNN on each filled ROI")
@DevelopmentStatus(DevelopmentStatus.Status.InDevelopment)
public class WhatWhereCNN extends DavisDeepLearnCnnProcessor {

    public static final String OUTPUT_AVAILBLE = "outputUpdated";

    private float alpha = getFloat("alpha",0.5f);

    private int filterx = 0, filtery = 0;  // Output location
    private DvsDataDrivenROIGenerator roiGenerator = null;

    public WhatWhereCNN(AEChip chip) {
        super(chip);

        roiGenerator = new DvsDataDrivenROIGenerator(chip);
        FilterChain chain = new FilterChain(chip);
        chain.add(roiGenerator); // only for control, we iterate with it here using the events we recieve
        setEnclosedFilterChain(chain);
        setPropertyTooltip("alpha", "how opaque the overlay of results is drawn");

        apsDvsNet.getSupport().addPropertyChangeListener(DeepLearnCnnNetwork.EVENT_MADE_DECISION, this);
    }

    @Override
    public synchronized EventPacket<?> filterPacket(EventPacket<?> in) {
        if (!addedPropertyChangeListener) {
//            ((AEFrameChipRenderer) chip.getRenderer()).getSupport().addPropertyChangeListener(AEFrameChipRenderer.EVENT_NEW_FRAME_AVAILBLE, this);
            if (roiGenerator != null) {
                roiGenerator.getSupport().addPropertyChangeListener(DvsDataDrivenROIGenerator.EVENT_NEW_ROI_AVAILABLE, this);
            }
            addedPropertyChangeListener = true;
        }

        resetTimeLimiter();
        if ((apsDvsNet != null)) {
            for (BasicEvent e : in) {

                if (timeLimiter.isTimedOut()) {
                    break; // discard rest of this packet
                }
                lastProcessedEventTimestamp = e.getTimestamp();
                PolarityEvent p = (PolarityEvent) e;

                roiGenerator.addEvent(p); // generates ROI complete EVENT_NEW_FRAME_AVAILBLE, no need to process frames here

            }
        }
        return in;
    }

    @Override
    public void resetFilter() {
        super.resetFilter();
        roiGenerator.resetFilter();
    }

    @Override
    public synchronized void setFilterEnabled(boolean yes) {
        super.setFilterEnabled(yes);
    }

    @Override
    public void annotate(GLAutoDrawable drawable) {
        super.annotate(drawable);
        GL2 gl = drawable.getGL().getGL2();
        checkBlend(gl);
        roiGenerator.annotate(drawable);
    }

    @Override
    public synchronized void propertyChange(PropertyChangeEvent evt) {
        switch (evt.getPropertyName()) {
            case AEFrameChipRenderer.EVENT_NEW_FRAME_AVAILBLE:
                break;
            case DvsDataDrivenROIGenerator.EVENT_NEW_ROI_AVAILABLE:
                long startTime = 0;
                if (measurePerformance) {
                    startTime = System.nanoTime();
                }
                DvsDataDrivenROIGenerator.ROI roi = (DvsDataDrivenROIGenerator.ROI) evt.getNewValue();
                apsDvsNet.processDvsTimeslice(roi); // generates PropertyChange EVENT_MADE_DECISION
                float[] activations = Arrays.copyOf(apsDvsNet.outputLayer.activations, apsDvsNet.outputLayer.getNumUnits());
                roi.setActivations(activations);
                float[] rgba = Arrays.copyOf(activations, 4);
                // alpha starts at 0, so fully transparent
                if (apsDvsNet.outputLayer.maxActivatedUnit != 3) { // background
                    rgba[3] = alpha; // set very tranparent and show decision as rgb
                } else {
                    Arrays.fill(rgba, 0); // don't show background at all
                }

                roi.setRgba(rgba); // for now just render 4-tuple as RGBA

                if (measurePerformance) {
                    long dt = System.nanoTime() - startTime;
                    float ms = 1e-6f * dt;
                    float fps = 1e3f / ms;
                    performanceString = String.format("Frame processing time: %.1fms (%.1f FPS); %s", ms, fps, apsDvsNet.getPerformanceString());
                }

                break;
            default:

        }

    }

    @Override
    public void setDvsMinEvents(int dvsMinEvents) {
        super.setDvsMinEvents(dvsMinEvents);
        roiGenerator.setDvsEventCount(dvsMinEvents);
    }

    /**
     * @return the alpha
     */
    public float getAlpha() {
        return alpha;
    }

    /**
     * @param alpha the alpha to set
     */
    public void setAlpha(float alpha) {
        if(alpha<0)alpha=0; else if(alpha>1)alpha=1;
        this.alpha = alpha;
        putFloat("alpha",alpha);
    }

}
