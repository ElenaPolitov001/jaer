/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package eu.visualize.ini.convnet;

import java.awt.Color;
import java.awt.Point;
import java.beans.PropertyChangeEvent;
import java.util.Arrays;

import javax.swing.SwingUtilities;

import com.jogamp.opengl.GL2;
import com.jogamp.opengl.GLAutoDrawable;

import ch.unizh.ini.jaer.projects.util.ColorHelper;
import com.jogamp.opengl.GL;
import com.jogamp.opengl.GLException;
import net.sf.jaer.Description;
import net.sf.jaer.DevelopmentStatus;
import net.sf.jaer.chip.AEChip;
import net.sf.jaer.event.BasicEvent;
import net.sf.jaer.event.EventPacket;
import net.sf.jaer.event.PolarityEvent;
import net.sf.jaer.eventprocessing.FilterChain;
import net.sf.jaer.graphics.AEFrameChipRenderer;
import net.sf.jaer.graphics.MultilineAnnotationTextRenderer;

/**
 * Runs CNN on patches generated by accumulated DVS subframes generated by
 * DvsDataDrivenROIGenerator to dynamically update a heat map in a data-driven
 * way.
 *
 * @author Tobi Delbruck
 *
 */
@Description("using data-driven ROIs from DVS events to update heat map by running CNN on each filled ROI")
@DevelopmentStatus(DevelopmentStatus.Status.InDevelopment)
public class WhatWhereCNN extends DavisDeepLearnCnnProcessor {

    public static final String OUTPUT_AVAILBLE = "outputUpdated";

    private TargetLabeler targetLabeler = null;
    private int totalDecisions = 0, correct = 0, incorrect = 0;
    private float alpha = 0.5f;
//    private float[][][][] heatMap;

    private int filterx = 0, filtery = 0;  // Output location
    private DvsDataDrivenROIGenerator roiGenerator = null;

    public WhatWhereCNN(AEChip chip) {
        super(chip);

        setPropertyTooltip("showAnalogDecisionOutput", "shows output units as analog shading");
        setPropertyTooltip("hideOutput", "All the output units are hided");
        setPropertyTooltip("processROI", "Regions of Interest will be processed");

        roiGenerator = new DvsDataDrivenROIGenerator(chip);
        FilterChain chain = new FilterChain(chip);
        chain.add(roiGenerator); // only for control, we iterate with it here using the events we recieve
        setEnclosedFilterChain(chain);

//        heatMap = null; // filled after net runs
        apsDvsNet.getSupport().addPropertyChangeListener(DeepLearnCnnNetwork.EVENT_MADE_DECISION, this);
    }

    @Override
    public synchronized EventPacket<?> filterPacket(EventPacket<?> in) {
        if (!addedPropertyChangeListener) {
//            ((AEFrameChipRenderer) chip.getRenderer()).getSupport().addPropertyChangeListener(AEFrameChipRenderer.EVENT_NEW_FRAME_AVAILBLE, this);
            if (roiGenerator != null) {
                roiGenerator.getSupport().addPropertyChangeListener(DvsDataDrivenROIGenerator.EVENT_NEW_ROI_AVAILABLE, this);
            }
            addedPropertyChangeListener = true;
        }

        resetTimeLimiter();
        if ((apsDvsNet != null)) {
            for (BasicEvent e : in) {

                if (timeLimiter.isTimedOut()) {
                    break; // discard rest of this packet
                }
                lastProcessedEventTimestamp = e.getTimestamp();
                PolarityEvent p = (PolarityEvent) e;

                roiGenerator.addEvent(p); // generates ROI complete EVENT_NEW_FRAME_AVAILBLE, no need to process frames here

            }
        }
        return in;
    }

    @Override
    public void resetFilter() {
        super.resetFilter();
        roiGenerator.resetFilter();
        totalDecisions = 0;
        correct = 0;
        incorrect = 0;
    }

    @Override
    public synchronized void setFilterEnabled(boolean yes) {
        super.setFilterEnabled(yes);
//        if (yes && !targetLabeler.hasLocations()) {
//            Runnable r = new Runnable() {
//
//                @Override
//                public void run() {
//                    targetLabeler.loadLastLocations();
//                }
//            };
//            SwingUtilities.invokeLater(r);
//        }
    }

    @Override
    public void annotate(GLAutoDrawable drawable) {
        super.annotate(drawable);
        GL2 gl = drawable.getGL().getGL2();
        checkBlend(gl);
        roiGenerator.annotate(drawable);
    }

//    private void checkHeatmap() {
//        if (heatMap != null) {
//            return;
//        }
//        if (apsDvsNet == null) {
//            return;
//        }
//        int nOut = apsDvsNet.outputLayer.getNumUnits();
//        if (nOut == 0) {
//            return;
//        }
//        heatMap = new float[roiGenerator.getNumScales()][roiGenerator.getNx()][roiGenerator.getNy()][nOut];
//    }

//    private void clearHeatMap() {
//        for (float[][][] f0 : heatMap) {
//            for (float[][] f1 : f0) {
//                for (float[] f2 : f1) {
//                    Arrays.fill(f2, 0);
//                }
//            }
//        }
//    }

//    public float[][][][] getHeatMap() {
//        return heatMap;
//    }

    @Override
    public synchronized void propertyChange(PropertyChangeEvent evt) {
        switch (evt.getPropertyName()) {
            case AEFrameChipRenderer.EVENT_NEW_FRAME_AVAILBLE:
                break;
            case DvsDataDrivenROIGenerator.EVENT_NEW_ROI_AVAILABLE:
                long startTime = 0;
                if (measurePerformance) {
                    startTime = System.nanoTime();
                }
                DvsDataDrivenROIGenerator.ROI roi = (DvsDataDrivenROIGenerator.ROI) evt.getNewValue();
                apsDvsNet.processDvsTimeslice(roi); // generates PropertyChange EVENT_MADE_DECISION
//                checkHeatmap();
                float[] activations=Arrays.copyOf(apsDvsNet.outputLayer.activations, apsDvsNet.outputLayer.getNumUnits());
                roi.setActivations(activations);
                roi.setRgba(activations); // for now just render 4-tuple as RGBA
                
                if (measurePerformance) {
                    long dt = System.nanoTime() - startTime;
                    float ms = 1e-6f * dt;
                    float fps = 1e3f / ms;
                    performanceString = String.format("Frame processing time: %.1fms (%.1f FPS); %s", ms, fps, apsDvsNet.getPerformanceString());
                }

                break;
            default:

        }

    }

    @Override
    public void setDvsMinEvents(int dvsMinEvents) {
        super.setDvsMinEvents(dvsMinEvents);
        roiGenerator.setDvsEventCount(dvsMinEvents);
    }
    
    
    
    
}
